package main

import (
	"log"
	"os"
	"strings"
	"text/template"

	_ "embed"
)

//go:embed instruction_encodings.txt
var encodings string

var sizes = map[string]int{
	"D":      1,
	"W":      1,
	"MOD":    2,
	"SR":     2,
	"REG":    3,
	"RM":     3,
	"DISPLO": 8,
	"DISPHI": 8,
	"DATA":   8,
	"DATAW":  8,
	"ADDRLO": 8,
	"ADDRHI": 8,
}

func sizeOf(val string) int {
	if size, ok := sizes[val]; ok {
		return size
	} else {
		return len(val)
	}
}

func nameOf(val string) string {
	if _, ok := sizes[val]; ok {
		return strings.ToLower(val)
	}
	return "const_" + val
}

type Opcode struct {
	Len  int
	Name string
}

type Part struct {
	Start int
	Len   int
	Name  string
	Orig  string
}

type Byte struct {
	Pos      int
	Parts    []Part
	HasModRM bool
}

type Encoding struct {
	Encoded string

	Name   string
	Bytes  []Byte
	Opcode Opcode
}

func main() {
	opcodes := map[Opcode][]Encoding{}
	for _, encoding := range strings.Split(encodings, "\n") {
		if len(encoding) == 0 {
			continue
		}
		if encoding[0] == '#' {
			continue
		}

		encodingS := strings.Split(encoding, " ")
		enc := Encoding{Encoded: encoding, Name: encodingS[0]}
		hasMod := false
		for pos, part := range encodingS[1:] {
			if len(part) == 0 {
				continue
			}

			total := 8

			i := 0
			b := Byte{Pos: pos}
			for _, p := range strings.Split(part, "_") {
				size := sizeOf(p)
				if p == "MOD" {
					hasMod = true
				}
				b.Parts = append(b.Parts, Part{
					Start: i,
					Len:   size,
					Name:  nameOf(p),
					Orig:  p,
				})
				if enc.Opcode.Name == "" {
					bp0 := b.Parts[0]
					enc.Opcode = Opcode{8 - bp0.Len, bp0.Orig}
				}
				i += size
				total -= size
			}
			if total != 0 {
				log.Fatalf("line %d (%s): invalid part %q doesn't equal 8 bits", i+1, encoding, part)
			}
			enc.Bytes = append(enc.Bytes, b)

			if hasMod {
				enc.Bytes = append(enc.Bytes, Byte{HasModRM: true})
				break
			}
		}
		opcodes[enc.Opcode] = append(opcodes[enc.Opcode], enc)
	}

	fd, err := os.Create("pkg/dissasemble.gen.go")
	if err != nil {
		log.Fatal(err)
	}
	defer fd.Close()

	funcMap := template.FuncMap{
		"mask": func(val int) string {
			m := ""
			for i := 0; i < val; i++ {
				m += "1"
			}
			return "0b" + m
		},
		"minus": func(v1, v2 int) int {
			return v2 - v1
		},
	}

	t := template.Must(template.New("dis").Funcs(funcMap).Parse(templ))

	if err := t.Execute(fd, map[string]any{"opcodes": opcodes}); err != nil {
		log.Fatal(err)
	}
}

var templ = `
// DO NOT EDIT: This file was autogenerated by cmd/codegen
package pkg

type Instruction struct {
	Name string
	D bool
	Field1 Field
	Field2 Field
}

type Field struct {
	reg1 byte
	reg2 byre
	imm  uint16
	size size
	ptr  bool
}

func disassemble(data []byte) []Instruction {
	di := 0

	// read next byte
	read := func() byte {
		b := data[di]
		di++
		return b
	}

	// read an 8-bit immediate
	rImm := func() uint16 {
		return uint16(read())
	}

	// read full 16-bit immediate
	rImmFull := func() uint16 {
		return rImm() | (rImm() << 8)
	}

	handleModRM := func(mod, rm, w byte) Field {
		var f Field
		switch mod {
		case 0b00: // Memory mode, no displacement *
			f.ptr = true
			if rm == 0b110 { // * special case
				f.imm = rImmFull()
			} else {
				ea := effectiveAddr[rm]
				f.reg1, f.reg2 = ea[0], ea[1]
				f.ptr = true
			}
		case 0b01: // Memory mode, 8-bit displacement
			ea := effectiveAddr[rm]
			f.reg1, f.reg2 = ea[0], ea[1]
			f.imm = rImm()
			f.ptr = true
		case 0b10: // Memory mode, 16-bit displacement
			ea := effectiveAddr[rm]
			f.reg1, f.reg2 = ea[0], ea[1]
			f.imm = rImmFull()
			f.ptr = true
		case 0b11: // Register mode (no displacement)
			f.reg1 = register(rm, w)
		}
		return f
	}

	for di < len(data) {
		in := newInstruction()
		b := read()
		bi := 0
		switch {
		{{- range $opcode, $entries := .opcodes}}
		case b>>{{$opcode.Len}} == 0b{{$opcode.Name}}:
			{{- range $entries}}
			// inst: {{.Encoded -}}
			in.name = "{{.Name}}"
			{{ $blen := .Bytes | len | minus 1 }}
			{{- range $index, $bytes := .Bytes}}
			{{if gt $index 0 }}{{if not .HasModRM}}b = read(){{end}}{{- end}}
			{{- range $bytes.Parts}}
			{{.Name}} := (b >> (8-({{.Start}} + {{.Len}}))) & {{ mask .Len}}
			{{- else}} 
			in.field1 = handleModRM(mod, rm, w)
			{{- end}}
			{{- end}}
			{{- end}}
		{{- end}}
		}
	}
}
`
